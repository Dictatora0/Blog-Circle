# Blog Circle 项目实验报告

## 一、GaussDB 一主二备集群部署（本地虚拟机）

### 1.1 部署架构

- **主库**：10.211.55.11:5432
- **备库 1**：10.211.55.11:5433
- **备库 2**：10.211.55.11:5434

### 1.2 关键配置文件

**`setup-gaussdb-single-vm-cluster.sh`** - 集群部署脚本

```bash
PRIMARY_DATA="/usr/local/opengauss/data_primary"
STANDBY1_DATA="/usr/local/opengauss/data_standby1"
STANDBY2_DATA="/usr/local/opengauss/data_standby2"

# 初始化主库
gs_initdb -D $PRIMARY_DATA --nodename=primary -w $DB_PASSWORD

# 配置主库 postgresql.conf
wal_level = replica
max_wal_senders = 10
wal_keep_size = 1024
hot_standby = on

# 从主库同步备库
gs_basebackup -h 127.0.0.1 -p $PRIMARY_PORT -U replicator \
  -D $STANDBY1_DATA -Fp -Xs -P -R
```

**`init-gaussdb-cluster.sh`** - 数据库初始化

```sql
CREATE DATABASE blog_db;
CREATE USER bloguser WITH PASSWORD '747599qw@';
GRANT ALL PRIVILEGES ON DATABASE blog_db TO bloguser;

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id INTEGER REFERENCES users(id),
    view_count INTEGER DEFAULT 0
);
```

### 1.3 主备复制配置

**主库 pg_hba.conf**：

```conf
host    replication     replicator     127.0.0.1/32          md5
host    all             bloguser       0.0.0.0/0             md5
```

**备库 postgresql.auto.conf**：

```conf
primary_conninfo = 'host=127.0.0.1 port=5432 user=replicator password=747599qw@'
primary_slot_name = 'standby1_slot'
hot_standby = on
```

### 1.4 启动方式

```bash
# 主库
su - omm -c "gs_ctl start -D /usr/local/opengauss/data_primary"

# 备库
su - omm -c "gs_ctl start -D /usr/local/opengauss/data_standby1"

# 验证复制状态
gsql -d postgres -p 5432 -c \
  'SELECT application_name, state FROM pg_stat_replication;'
```

---

## 二、容器化伪分布式 GaussDB 部署

### 2.1 Docker Compose 配置

**`docker-compose-gaussdb-pseudo.yml`**：

```yaml
services:
  gaussdb-primary:
    image: opengauss/opengauss:5.0.0
    container_name: gaussdb-primary
    ports:
      - "5432:5432"
    volumes:
      - gaussdb-data-primary:/var/lib/opengauss
    environment:
      - GS_PASSWORD=OpenGauss@123
      - GS_DB=blog_db

  gaussdb-standby1:
    image: opengauss/opengauss:5.0.0
    ports:
      - "5433:5432"
    depends_on:
      - gaussdb-primary
    command: >
      bash -c "
        gs_basebackup -h gaussdb-primary -p 5432 -U bloguser \
          -D /var/lib/opengauss -Fp -Xs -P
        touch /var/lib/opengauss/standby.signal
        exec gaussdb
      "
```

### 2.2 镜像构建

**`gaussdb-docker/Dockerfile-primary`**：

```dockerfile
FROM opengauss/opengauss:5.0.0
COPY entrypoint-primary.sh /docker-entrypoint-initdb.d/
ENV PGDATA=/var/lib/opengauss
EXPOSE 5432
```

**`entrypoint-primary.sh`**：

```bash
#!/bin/bash
cat >> $PGDATA/postgresql.conf << EOF
listen_addresses = '*'
wal_level = replica
max_wal_senders = 10
EOF
exec docker-entrypoint.sh postgres
```

### 2.3 容器启动

```bash
docker-compose -f docker-compose-gaussdb-pseudo.yml up -d
docker-compose ps
docker-compose logs -f gaussdb-primary
```

---

## 三、前后端分离 Web 应用

### 3.1 前端架构（Vue 3）

**技术栈**：Vue 3 + Vite + Element Plus + Axios

**页面结构**：

- `Login.vue` - 登录注册
- `Home.vue` - 动态流
- `Profile.vue` - 个人主页
- `Publish.vue` - 发布动态
- `Friends.vue` - 好友管理

**API 封装** (`src/utils/request.js`)：

```javascript
const request = axios.create({
  baseURL: "/api",
  timeout: 10000,
});

request.interceptors.request.use((config) => {
  const token = userStore.token;
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

**API 模块** (`src/api/post.js`)：

```javascript
export const getPostList = () => request({ url: "/posts/list", method: "get" });
export const createPost = (data) =>
  request({ url: "/posts", method: "post", data });
export const getPostDetail = (id) =>
  request({ url: `/posts/${id}/detail`, method: "get" });
```

### 3.2 后端架构（Spring Boot）

**技术栈**：Spring Boot 3.1.5 + MyBatis + HikariCP + Spark 3.5.0

**分层结构**：

```
controller/  - REST API 控制器
service/     - 业务逻辑层
mapper/      - 数据访问层（MyBatis）
entity/      - 实体类
config/      - 配置类
```

**控制器示例** (`PostController.java`)：

```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    @Autowired
    private PostService postService;

    @PostMapping
    public Result<Post> createPost(@RequestBody Post post, HttpServletRequest request) {
        Long userId = (Long) request.getAttribute("userId");
        post.setAuthorId(userId);
        return Result.success("发布成功", postService.createPost(post));
    }

    @GetMapping("/list")
    public Result<List<Post>> getAllPosts() {
        return Result.success(postService.getAllPosts());
    }

    @GetMapping("/{id}/detail")
    public Result<Post> getPostDetail(@PathVariable Long id) {
        return Result.success(postService.getPostById(id));
    }
}
```

**MyBatis Mapper** (`PostMapper.xml`)：

```xml
<mapper namespace="com.cloudcom.blog.mapper.PostMapper">
    <insert id="insert" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO posts (title, content, author_id, created_at)
        VALUES (#{title}, #{content}, #{authorId}, CURRENT_TIMESTAMP)
    </insert>

    <select id="selectAll" resultType="Post">
        SELECT * FROM posts ORDER BY created_at DESC
    </select>
</mapper>
```

---

## 四、前端 UI 与后端接口映射

### 4.1 登录功能

**前端** (`Login.vue`)：

```vue
<el-input v-model="loginForm.username" placeholder="用户名" />
<el-input v-model="loginForm.password" type="password" />
<el-button @click="handleLogin">登录</el-button>

<script>
const handleLogin = async () => {
  const res = await login(loginForm); // → POST /api/auth/login
  userStore.setToken(res.data.data.token);
};
</script>
```

**后端** (`AuthController.java`)：

```java
@PostMapping("/login")
public Result<Map<String, Object>> login(@RequestBody LoginRequest request) {
    User user = userService.login(request.getUsername(), request.getPassword());
    String token = JwtUtil.generateToken(user.getId());
    return Result.success("登录成功", Map.of("token", token, "user", user));
}
```

### 4.2 发布动态

**前端** (`Publish.vue`)：

```vue
<el-input v-model="content" type="textarea" />
<el-button @click="handlePublish">发布</el-button>

<script>
const handlePublish = async () => {
  await createPost({ content: content.value }); // → POST /api/posts
  router.push("/");
};
</script>
```

**后端** (`PostController.java`)：

```java
@PostMapping
public Result<Post> createPost(@RequestBody Post post, HttpServletRequest request) {
    Long userId = (Long) request.getAttribute("userId");
    post.setAuthorId(userId);
    return Result.success(postService.createPost(post));
}
```

### 4.3 点赞功能

**前端** (`MomentItem.vue`)：

```vue
<el-button @click="handleLike" :class="{ 'is-liked': liked }">
  <el-icon><Star /></el-icon> {{ likeCount }}
</el-button>

<script>
const handleLike = async () => {
  const res = await toggleLike(postId); // → POST /api/likes/{postId}
  liked.value = res.data.data.liked;
  likeCount.value = res.data.data.likeCount;
};
</script>
```

**后端** (`LikeController.java`)：

```java
@PostMapping("/{postId}")
public Result<Map<String, Object>> toggleLike(@PathVariable Long postId, HttpServletRequest request) {
    Long userId = (Long) request.getAttribute("userId");
    boolean liked = likeService.toggleLike(postId, userId);
    int count = likeService.getLikeCount(postId);
    return Result.success(Map.of("liked", liked, "likeCount", count));
}
```

### 4.4 评论功能

**前端** (`CommentSection.vue`)：

```vue
<el-input v-model="commentContent" />
<el-button @click="submitComment">发送</el-button>

<script>
const submitComment = async () => {
  await createComment({ postId, content: commentContent.value }); // → POST /api/comments
  await loadComments(); // → GET /api/comments/post/{postId}
};
</script>
```

**后端** (`CommentController.java`)：

```java
@PostMapping
public Result<Comment> createComment(@RequestBody Comment comment, HttpServletRequest request) {
    comment.setUserId((Long) request.getAttribute("userId"));
    return Result.success(commentService.createComment(comment));
}

@GetMapping("/post/{postId}")
public Result<List<Comment>> getComments(@PathVariable Long postId) {
    return Result.success(commentService.getCommentsByPostId(postId));
}
```

---

## 五、GaussDB 读写与 Spark 大数据分析

### 5.1 数据库连接配置

**`application-gaussdb-cluster.yml`**：

```yaml
spring:
  datasource:
    primary: # 主库（写操作）
      driver-class-name: org.opengauss.Driver
      jdbc-url: jdbc:opengauss://127.0.0.1:5432/blog_db
      username: bloguser
      password: Bloguser1234
      pool-name: GaussDB-Primary-HikariCP
    replica: # 备库（读操作）
      driver-class-name: org.opengauss.Driver
      jdbc-url: jdbc:opengauss://127.0.0.1:5432/blog_db
      username: bloguser
      password: Bloguser1234
      pool-name: GaussDB-Replica-HikariCP
```

### 5.2 读写分离配置

**`DataSourceConfig.java`**：

```java
@Configuration
public class DataSourceConfig {
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    }

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.replica")
    public DataSource replicaDataSource() {
        HikariDataSource ds = DataSourceBuilder.create().type(HikariDataSource.class).build();
        ds.setReadOnly(true);  // 只读模式
        return ds;
    }

    @Bean
    @Primary
    public DataSource routingDataSource(DataSource primary, DataSource replica) {
        DynamicRoutingDataSource routing = new DynamicRoutingDataSource();
        routing.setTargetDataSources(Map.of(
            DataSourceType.PRIMARY, primary,
            DataSourceType.REPLICA, replica
        ));
        routing.setDefaultTargetDataSource(primary);
        return routing;
    }
}
```

### 5.3 Spark 读写 GaussDB

**`SparkAnalyticsService.java`**：

```java
@Service
public class SparkAnalyticsService {
    @Value("${spring.datasource.primary.jdbc-url}")
    private String dbUrl;

    public void runSparkAnalytics() {
        SparkSession spark = SparkSession.builder()
            .appName("BlogAnalytics")
            .master("local[*]")
            .getOrCreate();

        Properties props = new Properties();
        props.setProperty("user", dbUsername);
        props.setProperty("password", dbPassword);
        props.setProperty("driver", "org.opengauss.Driver");

        // 从 GaussDB 读取数据
        Dataset<Row> posts = spark.read().jdbc(dbUrl, "posts", props);
        Dataset<Row> comments = spark.read().jdbc(dbUrl, "comments", props);

        // 统计分析
        Dataset<Row> userPostCounts = posts
            .groupBy("author_id")
            .count()
            .withColumnRenamed("count", "post_count");

        // 写回 GaussDB
        userPostCounts.write()
            .mode("append")
            .jdbc(dbUrl, "statistics", props);
    }
}
```

**`GaussDBClusterConfig.java`** - 集群读写配置：

```java
public class GaussDBClusterConfig {
    // 主库 URL（写操作）
    public static String getPrimaryJdbcUrl() {
        return "jdbc:postgresql://10.211.55.11:5432/blog_db";
    }

    // 备库 URL（读操作，负载均衡）
    public static String getReplicaJdbcUrl() {
        return "jdbc:postgresql://10.211.55.14:5432,10.211.55.13:5432/blog_db" +
               "?targetServerType=preferSlave&loadBalanceHosts=true";
    }

    // 从备库读取
    public static Dataset<Row> readFromReplica(SparkSession spark, String table) {
        return spark.read().jdbc(getReplicaJdbcUrl(), table, getReplicaProps());
    }

    // 写入主库
    public static void writeToPrimary(Dataset<Row> data, String table) {
        data.write().mode("append").jdbc(getPrimaryJdbcUrl(), table, getPrimaryProps());
    }
}
```

**`BlogAnalyticsClusterJob.java`** - Spark 任务：

```java
public class BlogAnalyticsClusterJob {
    public static void main(String[] args) {
        SparkSession spark = SparkSession.builder()
            .appName("BlogAnalyticsCluster")
            .getOrCreate();

        // 从备库读取（读操作）
        Dataset<Row> posts = GaussDBClusterConfig.readFromReplica(spark, "posts");
        Dataset<Row> comments = GaussDBClusterConfig.readFromReplica(spark, "comments");

        // 统计用户发文数
        Dataset<Row> userStats = posts.groupBy("author_id").count();

        // 写入主库（写操作）
        GaussDBClusterConfig.writeToPrimary(userStats, "statistics");
    }
}
```

---

## 六、Dockerfile 与容器化部署

### 6.1 后端 Dockerfile

**`backend/Dockerfile`**：

```dockerfile
# 构建阶段
FROM maven:3.8.7-eclipse-temurin-17 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B -Dmaven.test.skip=true
COPY src ./src
RUN mvn clean package -Dmaven.test.skip=true -B

# 运行阶段
FROM eclipse-temurin:17-jre
WORKDIR /app
RUN apt-get update && apt-get install -y curl
COPY --from=builder /app/target/*.jar app.jar
RUN mkdir -p /app/uploads
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**构建命令**：

```bash
docker build -t blogcircle-backend:gaussdb ./backend
```

### 6.2 前端 Dockerfile

**`frontend/Dockerfile`**：

```dockerfile
# 构建阶段
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# 运行阶段
FROM nginx:alpine
RUN apk add --no-cache netcat-openbsd
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**构建命令**：

```bash
docker build -t blogcircle-frontend:latest ./frontend
```

### 6.3 Docker Compose 部署

**`docker-compose-vm-gaussdb.yml`**：

```yaml
version: "3"
services:
  backend:
    image: blogcircle-backend:gaussdb
    container_name: blogcircle-backend
    network_mode: host
    volumes:
      - ./backend/src/main/resources/application-gaussdb-cluster.yml:/app/config/application-gaussdb-cluster.yml:ro
    entrypoint:
      - java
      - -Dspring.profiles.active=gaussdb-cluster
      - -Dspring.config.additional-location=file:/app/config/
      - -jar
      - app.jar
    environment:
      - SPRING_PROFILES_ACTIVE=gaussdb-cluster
      - SERVER_PORT=8081
      - JAVA_TOOL_OPTIONS=-Xms128m -Xmx256m

  frontend:
    build: ./frontend
    container_name: blogcircle-frontend
    ports:
      - "8080:80"
    depends_on:
      - backend
```

### 6.4 环境变量注入

**方式 1：Docker Compose 环境变量**：

```yaml
environment:
  - SPRING_PROFILES_ACTIVE=gaussdb-cluster
  - GAUSSDB_PRIMARY_URL=jdbc:opengauss://127.0.0.1:5432/blog_db
  - GAUSSDB_USERNAME=bloguser
  - GAUSSDB_PASSWORD=Bloguser1234
```

**方式 2：配置文件挂载**：

```yaml
volumes:
  - ./backend/src/main/resources/application-gaussdb-cluster.yml:/app/config/application-gaussdb-cluster.yml:ro
```

**方式 3：启动参数**：

```yaml
entrypoint:
  - java
  - -Dspring.profiles.active=gaussdb-cluster
  - -Dspring.config.additional-location=file:/app/config/
  - -jar
  - app.jar
```

### 6.5 容器启动流程

```bash
# 1. 构建镜像
docker build -t blogcircle-backend:gaussdb ./backend
docker build -t blogcircle-frontend:latest ./frontend

# 2. 保存镜像
docker save blogcircle-backend:gaussdb -o backend-gaussdb.tar

# 3. 传输到虚拟机
scp backend-gaussdb.tar root@10.211.55.11:~/

# 4. 在虚拟机加载镜像
docker load -i ~/backend-gaussdb.tar

# 5. 启动容器
docker-compose -f docker-compose-vm-gaussdb.yml up -d

# 6. 查看日志
docker-compose -f docker-compose-vm-gaussdb.yml logs -f

# 7. 验证服务
curl http://localhost:8080/api/posts/list
```

### 6.6 与 GaussDB 连接配置

**后端连接配置**（通过 host 网络模式直接访问宿主机 GaussDB）：

```yaml
backend:
  network_mode: host # 使用宿主机网络
  environment:
    - SPRING_DATASOURCE_URL=jdbc:opengauss://127.0.0.1:5432/blog_db
```

**前端 Nginx 代理配置** (`nginx.conf`)：

```nginx
server {
    listen 80;

    location /api {
        proxy_pass http://127.0.0.1:8081;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    location /uploads {
        proxy_pass http://127.0.0.1:8081;
    }
}
```

---

## 七、项目总结

### 7.1 实现的功能

1. ✅ GaussDB 一主二备集群（本地虚拟机 + 容器化）
2. ✅ 前后端分离架构（Vue 3 + Spring Boot）
3. ✅ 完整的 CRUD 功能（用户、文章、评论、点赞）
4. ✅ Spark 大数据分析（读备库、写主库）
5. ✅ Docker 容器化部署
6. ✅ 读写分离与负载均衡

### 7.2 技术亮点

- **数据库高可用**：一主二备流复制，自动故障转移
- **读写分离**：写操作主库，读操作备库负载均衡
- **大数据分析**：Spark 对 GaussDB 进行分布式计算
- **容器化部署**：多阶段构建，镜像优化
- **前后端分离**：RESTful API，JWT 认证

### 7.3 部署架构图

```
┌─────────────────────────────────────────┐
│         Frontend (Vue 3 + Nginx)        │
│              Port: 8080                  │
└──────────────┬──────────────────────────┘
               │ HTTP /api
               ↓
┌─────────────────────────────────────────┐
│      Backend (Spring Boot + Spark)      │
│              Port: 8081                  │
└──────────┬──────────────────────────────┘
           │
           ↓
┌──────────────────────────────────────────┐
│         GaussDB Cluster (1主2备)         │
│  Primary:5432  Standby1:5433  Standby2:5434 │
│  ├─ 写操作 → Primary                      │
│  └─ 读操作 → Standby1/Standby2 (负载均衡) │
└──────────────────────────────────────────┘
```

### 7.4 测试结果

所有 API 测试通过（10/10）：

- ✅ 注册/登录
- ✅ 创建/查询文章
- ✅ 点赞/评论
- ✅ 健康检查
