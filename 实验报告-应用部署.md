# Blog Circle 系统实验报告 - 应用部署

## 四、应用部署

### 4.1 部署架构设计

#### 4.1.1 部署拓扑

本实验采用虚拟机真实集群部署，模拟生产环境的完整架构：

```
虚拟机真实集群（生产环境）
VM 10.211.55.11 (openEuler 22.03 LTS)
├── openGauss 9.2.4 数据库集群
│   ├── Primary Node (主库)
│   │   ├── 端口: 5432 (数据) + 5433 (HA)
│   │   ├── 角色: 写操作 + 主备复制源
│   │   └── 数据目录: /usr/local/opengauss/data_primary
│   ├── Standby1 Node (备库1)
│   │   ├── 端口: 5434 (数据) + 5435 (HA)
│   │   ├── 角色: 读操作 + 主备复制目标
│   │   └── 数据目录: /usr/local/opengauss/data_standby1
│   └── Standby2 Node (备库2)
│       ├── 端口: 5436 (数据) + 5437 (HA)
│       ├── 角色: 读操作 + 主备复制目标
│       └── 数据目录: /usr/local/opengauss/data_standby2
├── Spring Boot 后端服务
│   ├── 端口: 8081
│   ├── 功能: REST API + 读写分离路由 + Spark 分析
│   ├── JVM: OpenJDK 17
│   └── 日志: /root/CloudCom/backend/logs/
├── Vue 3 前端服务
│   ├── 端口: 8080
│   ├── 部署方式: Nginx 静态托管
│   └── 配置: /etc/nginx/conf.d/blog.conf
└── Apache Spark 3.5.0
    ├── 运行模式: local[*] (内嵌在后端)
    ├── 功能: 大数据分析 + 统计计算
    └── 备用方案: SQL 直接查询
```

#### 4.1.2 架构特点

**高可用设计**：

- 一主二备流复制架构，主库故障可快速切换
- 备库实时同步主库数据，RPO < 1s
- 读操作分布到备库，降低主库负载

**性能优化**：

- HikariCP 连接池管理，主库 20 连接，备库 20 连接
- AOP 动态路由实现读写分离，无需修改业务代码
- Spark 内嵌模式处理大数据分析，失败自动回退 SQL

**部署便捷性**：

- 单机多实例部署，节约资源
- 自动化脚本管理集群生命周期
- 统一的配置管理和日志监控

### 4.2 虚拟机环境准备

#### 4.2.1 硬件与操作系统

**虚拟机配置**：

| 配置项   | 规格                | 说明                  |
| -------- | ------------------- | --------------------- |
| IP 地址  | 10.211.55.11        | 内网固定 IP           |
| 操作系统 | openEuler 22.03 LTS | 华为开源 Linux 发行版 |
| CPU      | 4 核 (2.4GHz)       | 支持多实例并发        |
| 内存     | 8GB                 | 数据库 + 应用共享     |
| 磁盘     | 100GB SSD           | 数据库数据 + 日志存储 |
| 网络     | 千兆以太网          | 低延迟局域网          |

**系统初始化**：

```bash
# 1. 更新系统软件包
yum update -y

# 2. 设置主机名
hostnamectl set-hostname gaussdb-cluster

# 3. 配置防火墙规则
firewall-cmd --permanent --add-port=5432/tcp  # 主库
firewall-cmd --permanent --add-port=5434/tcp  # 备库1
firewall-cmd --permanent --add-port=5436/tcp  # 备库2
firewall-cmd --permanent --add-port=8080/tcp  # 前端
firewall-cmd --permanent --add-port=8081/tcp  # 后端
firewall-cmd --reload

# 4. 配置系统参数
cat >> /etc/sysctl.conf << EOF
kernel.sem = 250 32000 100 999
kernel.shmmax = 4294967296
kernel.shmall = 1073741824
net.ipv4.tcp_max_tw_buckets = 10000
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_keepalive_time = 30
net.ipv4.tcp_keepalive_intvl = 10
EOF
sysctl -p

# 5. 创建 omm 用户（openGauss 管理用户）
groupadd dbgrp
useradd -g dbgrp omm
echo "747599qw@" | passwd --stdin omm
```

#### 4.2.2 软件依赖安装

**基础软件**：

```bash
# 1. 安装 JDK 17
wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz
tar -xzf jdk-17_linux-x64_bin.tar.gz -C /usr/local/
ln -s /usr/local/jdk-17.0.9 /usr/local/java

# 配置环境变量
cat >> /etc/profile << EOF
export JAVA_HOME=/usr/local/java
export PATH=\$JAVA_HOME/bin:\$PATH
EOF
source /etc/profile
java -version  # 验证安装

# 2. 安装 Maven 3.8.x
wget https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz
tar -xzf apache-maven-3.8.8-bin.tar.gz -C /usr/local/
ln -s /usr/local/apache-maven-3.8.8 /usr/local/maven

cat >> /etc/profile << EOF
export MAVEN_HOME=/usr/local/maven
export PATH=\$MAVEN_HOME/bin:\$PATH
EOF
source /etc/profile
mvn -version  # 验证安装

# 3. 安装 Node.js 18.x
curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
yum install -y nodejs
node -v  # 验证安装
npm -v

# 4. 安装 Nginx
yum install -y nginx
systemctl enable nginx

# 5. 安装开发工具
yum install -y git vim wget curl lsof net-tools rsync
```

**openGauss 9.2.4 安装**：

```bash
# 1. 下载 openGauss
su - omm
wget https://opengauss.obs.cn-south-1.myhuaweicloud.com/9.2.4/x86/openGauss-9.2.4-openEuler-64bit.tar.bz2

# 2. 解压安装包
mkdir -p /usr/local/opengauss
tar -xjf openGauss-9.2.4-openEuler-64bit.tar.bz2 -C /usr/local/opengauss/

# 3. 配置环境变量
cat >> ~/.bashrc << EOF
export GAUSSHOME=/usr/local/opengauss
export PATH=\$GAUSSHOME/bin:\$PATH
export LD_LIBRARY_PATH=\$GAUSSHOME/lib:\$LD_LIBRARY_PATH
EOF
source ~/.bashrc

# 4. 验证安装
gs_ctl --version
# 输出: gs_ctl (openGauss) 9.2.4
```

### 4.3 openGauss 集群部署

#### 4.3.1 集群初始化（续）

**步骤 1：同步代码到虚拟机**

```bash
# 在本地 Mac 上执行
./sync-scripts-to-vm.sh

# 或手动同步
sshpass -p "747599qw@" rsync -avz \
  --exclude='node_modules' \
  --exclude='target' \
  --exclude='.git' \
  ./ root@10.211.55.11:~/CloudCom/

# 验证同步结果
ssh root@10.211.55.11 "ls -la ~/CloudCom/"
```

**步骤 2：使用自动化脚本部署集群**

```bash
# SSH 登录虚拟机
ssh root@10.211.55.11
cd ~/CloudCom

# 方案 A：快速部署（集群已存在）
./scripts/refactor-ports.sh           # 重配置端口
./scripts/verify-gaussdb-cluster.sh   # 验证集群状态

# 方案 B：完整部署（首次部署）
./setup-gaussdb-single-vm-cluster.sh  # 初始化三个实例
./scripts/refactor-ports.sh           # 配置正确端口
./scripts/verify-gaussdb-cluster.sh   # 验证集群状态
```

**步骤 3：手动初始化主库（可选）**

如果自动化脚本失败，可手动初始化：

```bash
# 1. 切换到 omm 用户
su - omm

# 2. 初始化主库数据目录
gs_initdb -D /usr/local/opengauss/data_primary \
  --nodename=primary \
  --encoding=UTF8 \
  --locale=en_US.UTF-8 \
  -w 747599qw@

# 3. 配置 postgresql.conf
cat >> /usr/local/opengauss/data_primary/postgresql.conf << EOF
# 网络配置
listen_addresses = '*'
port = 5432
max_connections = 200

# 复制配置
wal_level = replica
max_wal_senders = 10
wal_keep_segments = 128
synchronous_standby_names = ''

# 性能配置
shared_buffers = 256MB
effective_cache_size = 1GB
maintenance_work_mem = 64MB
EOF

# 4. 配置 pg_hba.conf
cat >> /usr/local/opengauss/data_primary/pg_hba.conf << EOF
# 允许本地连接
host    all    all    127.0.0.1/32    md5
host    all    all    10.211.55.11/32 md5

# 允许复制连接
host    replication    replicator    127.0.0.1/32    md5
host    replication    replicator    10.211.55.11/32 md5
EOF

# 5. 启动主库
gs_ctl start -D /usr/local/opengauss/data_primary

# 6. 创建数据库和用户
gsql -d postgres -p 5432 << EOF
CREATE DATABASE blog_db ENCODING 'UTF8';
CREATE USER bloguser WITH PASSWORD '747599qw@';
GRANT ALL PRIVILEGES ON DATABASE blog_db TO bloguser;
CREATE USER replicator WITH REPLICATION PASSWORD '747599qw@';
\q
EOF
```

**步骤 4：初始化备库**

```bash
# 仍在 omm 用户下

# 1. 使用 gs_basebackup 从主库同步备库1
gs_basebackup -h 127.0.0.1 -p 5432 -U replicator \
  -D /usr/local/opengauss/data_standby1 \
  -X stream -P -v

# 2. 配置备库1的端口和复制
cat >> /usr/local/opengauss/data_standby1/postgresql.conf << EOF
port = 5434
hot_standby = on
max_standby_streaming_delay = 30s
wal_receiver_status_interval = 10s
hot_standby_feedback = on
EOF

# 3. 创建 standby.signal 文件（标记为备库）
touch /usr/local/opengauss/data_standby1/standby.signal

# 4. 配置主库连接信息
cat > /usr/local/opengauss/data_standby1/postgresql.auto.conf << EOF
primary_conninfo = 'host=127.0.0.1 port=5432 user=replicator password=747599qw@'
EOF

# 5. 启动备库1
gs_ctl start -D /usr/local/opengauss/data_standby1

# 6. 同样方式初始化备库2
gs_basebackup -h 127.0.0.1 -p 5432 -U replicator \
  -D /usr/local/opengauss/data_standby2 \
  -X stream -P -v

cat >> /usr/local/opengauss/data_standby2/postgresql.conf << EOF
port = 5436
hot_standby = on
max_standby_streaming_delay = 30s
EOF

touch /usr/local/opengauss/data_standby2/standby.signal

cat > /usr/local/opengauss/data_standby2/postgresql.auto.conf << EOF
primary_conninfo = 'host=127.0.0.1 port=5432 user=replicator password=747599qw@'
EOF

gs_ctl start -D /usr/local/opengauss/data_standby2
```

**步骤 5：验证集群状态**

```bash
# 1. 检查进程状态
ps aux | grep gaussdb
# 应显示 3 个 gaussdb 进程

# 2. 检查端口监听
lsof -i :5432,5434,5436
# 应显示 3 个端口都在监听

# 3. 检查复制状态（在主库上）
gsql -d postgres -p 5432 -c "SELECT * FROM pg_stat_replication;"
# 应显示 2 条记录，表示 2 个备库连接成功

# 4. 检查备库恢复模式
gsql -d postgres -p 5434 -c "SELECT pg_is_in_recovery();"
# 应返回 t (true)

gsql -d postgres -p 5436 -c "SELECT pg_is_in_recovery();"
# 应返回 t (true)

# 5. 测试主备数据同步
# 在主库写入数据
gsql -d blog_db -p 5432 -c "CREATE TABLE test_sync (id INT, data TEXT);"
gsql -d blog_db -p 5432 -c "INSERT INTO test_sync VALUES (1, 'test data');"

# 在备库查询（应能查到）
sleep 2
gsql -d blog_db -p 5434 -c "SELECT * FROM test_sync;"
gsql -d blog_db -p 5436 -c "SELECT * FROM test_sync;"
```

#### 4.3.2 数据库初始化

**创建表结构**：

```bash
# 1. 执行初始化脚本
su - omm
gsql -d blog_db -p 5432 -f /root/CloudCom/backend/src/main/resources/db/01_init.sql

# 2. 验证表结构
gsql -d blog_db -p 5432 << EOF
\dt
\d users
\d posts
\d comments
\d likes
\d friendships
\d access_logs
\d statistics
\q
EOF
```

**初始化测试数据**：

```bash
# 插入管理员账号
gsql -d blog_db -p 5432 << EOF
INSERT INTO users (username, password, email, nickname, created_at, updated_at)
VALUES ('admin', '\$2a\$10\$N.zmdr9k7uOCQvjrSvMGCOe3nDuoMR0fX8xPuOY2OmNWNfZpAV8',
        'admin@example.com', '系统管理员', NOW(), NOW());

INSERT INTO users (username, password, email, nickname, created_at, updated_at)
VALUES ('testuser', '\$2a\$10\$N.zmdr9k7uOCQvjrSvMGCOe3nDuoMR0fX8xPuOY2OmNWNfZpAV8',
        'test@example.com', '测试用户', NOW(), NOW());
\q
EOF

# 验证数据
gsql -d blog_db -p 5432 -c "SELECT username, email FROM users;"
```

### 4.4 后端服务部署

#### 4.4.1 代码编译

```bash
# 1. 进入后端目录
cd /root/CloudCom/backend

# 2. 配置 Maven（使用国内镜像）
mkdir -p ~/.m2
cat > ~/.m2/settings.xml << EOF
<settings>
  <mirrors>
    <mirror>
      <id>aliyun</id>
      <mirrorOf>central</mirrorOf>
      <name>Aliyun Maven</name>
      <url>https://maven.aliyun.com/repository/public</url>
    </mirror>
  </mirrors>
</settings>
EOF

# 3. 清理并编译
mvn clean package -DskipTests

# 编译成功后，jar 包位置：
# target/blog-backend-1.0.0.jar
```

#### 4.4.2 配置文件

**application-gaussdb-cluster.yml**：

```yaml
spring:
  application:
    name: blog-system
  datasource:
    # 主库配置（写操作）
    primary:
      driver-class-name: org.opengauss.Driver
      jdbc-url: jdbc:opengauss://10.211.55.11:5432/blog_db
      username: bloguser
      password: 747599qw@
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000
        validation-timeout: 5000
        connection-test-query: SELECT 1
        pool-name: GaussDB-Primary-HikariCP

    # 备库配置（读操作）
    replica:
      driver-class-name: org.opengauss.Driver
      jdbc-url: jdbc:opengauss://10.211.55.11:5434/blog_db
      username: bloguser
      password: 747599qw@
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000
        validation-timeout: 5000
        connection-test-query: SELECT 1
        pool-name: GaussDB-Replica-HikariCP

mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.cloudcom.blog.entity
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# Spark 配置
spark:
  enabled: true # 启用 Spark 分析

# JWT 配置
jwt:
  secret: cloudcom-blog-system-secret-key-2025
  expiration: 86400000

# 文件上传配置
file:
  upload:
    path: /root/CloudCom/uploads
    url-prefix: /uploads

# 服务器配置
server:
  port: 8081

# 日志配置
logging:
  level:
    com.cloudcom.blog: INFO
    org.opengauss: WARN
    com.zaxxer.hikari: DEBUG
  file:
    name: /root/CloudCom/backend/logs/blog-backend.log
    max-size: 100MB
    max-history: 30
```

#### 4.4.3 启动服务

```bash
# 1. 创建日志目录
mkdir -p /root/CloudCom/backend/logs
mkdir -p /root/CloudCom/uploads

# 2. 启动后端服务
cd /root/CloudCom/backend
nohup java -jar target/blog-backend-1.0.0.jar \
  --spring.profiles.active=gaussdb-cluster \
  -Xms512m -Xmx1024m \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  > logs/backend.log 2>&1 &

# 3. 记录进程 ID
echo $! > /root/CloudCom/backend/backend.pid

# 4. 查看启动日志
tail -f logs/backend.log

# 等待启动成功，日志显示：
# Started BlogSystemApplication in XX.XXX seconds
```

#### 4.4.4 验证后端服务

```bash
# 1. 检查进程
ps aux | grep blog-backend

# 2. 检查端口
lsof -i :8081

# 3. 测试健康检查接口
curl http://10.211.55.11:8081/actuator/health
# 预期输出: {"status":"UP"}

# 4. 测试数据库连接
curl http://10.211.55.11:8081/api/posts/list
# 应返回空数组或文章列表

# 5. 测试读写分离
# 查看日志中的 HikariCP 连接信息
tail -100 logs/backend.log | grep "HikariCP"
# 应看到 Primary 和 Replica 两个连接池初始化
```

### 4.5 前端服务部署

#### 4.5.1 构建前端

```bash
# 1. 进入前端目录
cd /root/CloudCom/frontend

# 2. 配置环境变量
cat > .env.production << EOF
VITE_API_BASE_URL=http://10.211.55.11:8081
VITE_APP_TITLE=Blog Circle
VITE_UPLOAD_SIZE_LIMIT=10485760
EOF

# 3. 安装依赖（使用国内镜像）
npm config set registry https://registry.npmmirror.com
npm install

# 4. 构建生产版本
npm run build

# 构建完成后，产物在 dist/ 目录
ls -la dist/
```

#### 4.5.2 配置 Nginx

```bash
# 1. 备份默认配置
cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak

# 2. 创建站点配置
cat > /etc/nginx/conf.d/blog.conf << 'EOF'
server {
    listen 8080;
    server_name 10.211.55.11;

    root /usr/share/nginx/html/blog;
    index index.html;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript
               application/x-javascript application/xml+rss
               application/json application/javascript;

    # 前端路由
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API 代理
    location /api {
        proxy_pass http://127.0.0.1:8081;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 超时配置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # 文件上传
    location /uploads {
        alias /root/CloudCom/uploads;
        expires 7d;
        add_header Cache-Control "public, immutable";
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 30d;
        add_header Cache-Control "public, immutable";
    }
}
EOF

# 3. 部署前端文件
mkdir -p /usr/share/nginx/html/blog
cp -r /root/CloudCom/frontend/dist/* /usr/share/nginx/html/blog/

# 4. 测试配置
nginx -t

# 5. 启动 Nginx
systemctl restart nginx
systemctl enable nginx

# 6. 检查状态
systemctl status nginx
```

#### 4.5.3 验证前端服务

```bash
# 1. 检查 Nginx 进程
ps aux | grep nginx

# 2. 检查端口监听
lsof -i :8080

# 3. 测试首页访问
curl -I http://10.211.55.11:8080
# 预期: HTTP/1.1 200 OK

# 4. 测试静态资源
curl -I http://10.211.55.11:8080/assets/index.js
# 预期: HTTP/1.1 200 OK

# 5. 在浏览器访问
# http://10.211.55.11:8080
```

### 4.6 服务运维管理

#### 4.6.1 集群管理脚本

**启动所有服务（start-all.sh）**：

```bash
#!/bin/bash
set -e

echo "========================================="
echo "启动 Blog Circle 系统所有服务"
echo "========================================="

# 1. 启动 openGauss 集群
echo "[1/3] 启动 openGauss 数据库集群..."
su - omm -c "gs_ctl start -D /usr/local/opengauss/data_primary"
su - omm -c "gs_ctl start -D /usr/local/opengauss/data_standby1"
su - omm -c "gs_ctl start -D /usr/local/opengauss/data_standby2"

# 等待数据库启动
sleep 5

# 验证集群状态
echo "验证集群状态..."
su - omm -c "gs_ctl status -D /usr/local/opengauss/data_primary"
su - omm -c "gsql -d postgres -p 5432 -c 'SELECT * FROM pg_stat_replication;'"

# 2. 启动后端服务
echo "[2/3] 启动 Spring Boot 后端服务..."
cd /root/CloudCom/backend
nohup java -jar target/blog-backend-1.0.0.jar \
  --spring.profiles.active=gaussdb-cluster \
  -Xms512m -Xmx1024m \
  -XX:+UseG1GC \
  > logs/backend.log 2>&1 &
  
echo $! > backend.pid
sleep 10

# 验证后端启动
curl -f http://localhost:8081/actuator/health || echo "后端启动失败！"

# 3. 启动 Nginx
echo "[3/3] 启动 Nginx 前端服务..."
systemctl restart nginx

# 最终验证
echo "========================================="
echo "服务启动完成，验证中..."
echo "========================================="
lsof -i :5432,5434,5436,8080,8081
echo "========================================="
echo "所有服务已启动完成！"
echo "前端访问: http://10.211.55.11:8080"
echo "后端 API: http://10.211.55.11:8081"
echo "========================================="
```

**停止所有服务（stop-all.sh）**：

```bash
#!/bin/bash

echo "========================================="
echo "停止 Blog Circle 系统所有服务"
echo "========================================="

# 1. 停止 Nginx
echo "[1/3] 停止 Nginx 服务..."
systemctl stop nginx

# 2. 停止后端服务
echo "[2/3] 停止后端服务..."
if [ -f /root/CloudCom/backend/backend.pid ]; then
    kill $(cat /root/CloudCom/backend/backend.pid) 2>/dev/null || true
    rm -f /root/CloudCom/backend/backend.pid
else
    pkill -f blog-backend || true
fi

# 3. 停止 openGauss 集群
echo "[3/3] 停止 openGauss 集群..."
su - omm -c "gs_ctl stop -D /usr/local/opengauss/data_standby2 -m fast"
su - omm -c "gs_ctl stop -D /usr/local/opengauss/data_standby1 -m fast"
su - omm -c "gs_ctl stop -D /usr/local/opengauss/data_primary -m fast"

echo "========================================="
echo "所有服务已停止"
echo "========================================="
```

**查看服务状态（status-all.sh）**：

```bash
#!/bin/bash

echo "========================================="
echo "Blog Circle 系统状态检查"
echo "========================================="

echo ""
echo "[1] openGauss 数据库集群状态"
echo "-----------------------------------------"
echo "主库 (5432):"
su - omm -c "gs_ctl status -D /usr/local/opengauss/data_primary" 2>/dev/null || echo "  未运行"

echo ""
echo "备库1 (5434):"
su - omm -c "gs_ctl status -D /usr/local/opengauss/data_standby1" 2>/dev/null || echo "  未运行"

echo ""
echo "备库2 (5436):"
su - omm -c "gs_ctl status -D /usr/local/opengauss/data_standby2" 2>/dev/null || echo "  未运行"

echo ""
echo "复制状态:"
su - omm -c "gsql -d postgres -p 5432 -c 'SELECT application_name, state, sync_state FROM pg_stat_replication;'" 2>/dev/null || echo "  查询失败"

echo ""
echo "[2] Spring Boot 后端状态"
echo "-----------------------------------------"
if pgrep -f "blog-backend" > /dev/null; then
    echo "✓ 后端服务运行中 (PID: $(pgrep -f blog-backend))"
    curl -s http://localhost:8081/actuator/health | grep -q "UP" && echo "✓ 健康检查通过" || echo "✗ 健康检查失败"
else
    echo "✗ 后端服务未运行"
fi

echo ""
echo "[3] Nginx 前端状态"
echo "-----------------------------------------"
systemctl is-active nginx >/dev/null 2>&1 && echo "✓ Nginx 运行中" || echo "✗ Nginx 未运行"

echo ""
echo "[4] 端口监听情况"
echo "-----------------------------------------"
lsof -i :5432,5434,5436,8080,8081 2>/dev/null || echo "无端口监听"

echo ""
echo "========================================="
```

#### 4.6.2 日志管理

**日志文件位置**：

| 组件 | 日志路径 | 说明 |
|------|---------|------|
| openGauss 主库 | `/usr/local/opengauss/data_primary/pg_log/` | 数据库运行日志 |
| openGauss 备库1 | `/usr/local/opengauss/data_standby1/pg_log/` | 备库运行日志 |
| openGauss 备库2 | `/usr/local/opengauss/data_standby2/pg_log/` | 备库运行日志 |
| Spring Boot 后端 | `/root/CloudCom/backend/logs/blog-backend.log` | 应用日志 |
| Nginx 访问日志 | `/var/log/nginx/access.log` | HTTP 访问日志 |
| Nginx 错误日志 | `/var/log/nginx/error.log` | HTTP 错误日志 |
| 系统日志 | `/var/log/messages` | 系统级日志 |

**日志查看命令**：

```bash
# 查看后端实时日志
tail -f /root/CloudCom/backend/logs/blog-backend.log

# 查看后端错误日志
grep -i error /root/CloudCom/backend/logs/blog-backend.log

# 查看数据库主库日志
tail -f /usr/local/opengauss/data_primary/pg_log/postgresql-$(date +%Y-%m-%d).log

# 查看 HikariCP 连接池日志（验证读写分离）
grep "HikariCP" /root/CloudCom/backend/logs/blog-backend.log

# 查看 Spark 分析日志
grep "Spark" /root/CloudCom/backend/logs/blog-backend.log

# 查看 Nginx 访问日志
tail -f /var/log/nginx/access.log

# 查看慢查询（假设配置了慢查询）
grep -A 5 "slow query" /usr/local/opengauss/data_primary/pg_log/*.log
```

**日志轮转配置**：

```bash
# 创建日志轮转配置
cat > /etc/logrotate.d/blog-system << EOF
/root/CloudCom/backend/logs/*.log {
    daily
    rotate 30
    compress
    delaycompress
    notifempty
    create 0644 root root
    sharedscripts
    postrotate
        pkill -HUP -f blog-backend || true
    endscript
}

/var/log/nginx/*.log {
    daily
    rotate 30
    compress
    delaycompress
    notifempty
    create 0644 nginx nginx
    sharedscripts
    postrotate
        systemctl reload nginx || true
    endscript
}
EOF
```

#### 4.6.3 监控与告警

**系统资源监控**：

```bash
# CPU 使用率
top -b -n 1 | grep "Cpu(s)"

# 内存使用率
free -h

# 磁盘使用率
df -h

# 数据库连接数
su - omm -c "gsql -d blog_db -p 5432 -c 'SELECT count(*) FROM pg_stat_activity;'"

# 数据库表大小
su - omm -c "gsql -d blog_db -p 5432 -c '\dt+'"

# 后端 JVM 内存使用
jps -lv | grep blog-backend
```

**数据库性能监控**：

```bash
# 查看活动连接
su - omm -c "gsql -d blog_db -p 5432 -c 'SELECT pid, usename, application_name, client_addr, state, query FROM pg_stat_activity WHERE state = '\''active'\'';'"

# 查看复制延迟
su - omm -c "gsql -d postgres -p 5432 -c 'SELECT application_name, client_addr, state, sync_state, replay_lag FROM pg_stat_replication;'"

# 查看缓存命中率
su - omm -c "gsql -d blog_db -p 5432 -c 'SELECT sum(blks_hit)*100/sum(blks_hit+blks_read) as cache_hit_ratio FROM pg_stat_database;'"

# 查看表的读写统计
su - omm -c "gsql -d blog_db -p 5432 -c 'SELECT schemaname, tablename, seq_scan, idx_scan, n_tup_ins, n_tup_upd, n_tup_del FROM pg_stat_user_tables;'"
```

### 4.7 部署验证与测试

#### 4.7.1 完整性验证清单

| 检查项 | 验证命令 | 预期结果 |
|-------|---------|---------|
| 主库运行状态 | `gs_ctl status -D data_primary` | `server is running` |
| 备库1运行状态 | `gs_ctl status -D data_standby1` | `server is running` |
| 备库2运行状态 | `gs_ctl status -D data_standby2` | `server is running` |
| 主备复制状态 | `gsql -p 5432 -c 'SELECT * FROM pg_stat_replication;'` | 显示 2 个备库 |
| 备库恢复模式 | `gsql -p 5434 -c 'SELECT pg_is_in_recovery();'` | 返回 `t` |
| 端口监听 | `lsof -i :5432,5434,5436,8080,8081` | 5个端口监听 |
| 后端健康检查 | `curl http://10.211.55.11:8081/actuator/health` | `{"status":"UP"}` |
| 前端访问 | `curl -I http://10.211.55.11:8080` | `200 OK` |
| API 接口 | `curl http://10.211.55.11:8081/api/posts/list` | 返回 JSON |
| 数据库连接池 | `grep "HikariCP" backend/logs/blog-backend.log` | 主备两个连接池 |

#### 4.7.2 功能测试

**1. 用户注册登录测试**：

```bash
# 注册新用户
curl -X POST http://10.211.55.11:8081/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "password": "test123456",
    "email": "test@example.com",
    "nickname": "测试用户"
  }'

# 用户登录
TOKEN=$(curl -X POST http://10.211.55.11:8081/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"test123456"}' \
  | jq -r '.data.token')

echo "Token: $TOKEN"
```

**2. 文章操作测试**：

```bash
# 创建文章（写操作 → 主库）
POST_ID=$(curl -X POST http://10.211.55.11:8081/api/posts \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "测试文章",
    "content": "这是一篇测试文章内容",
    "tags": ["测试", "技术"]
  }' \
  | jq -r '.data.id')

echo "文章ID: $POST_ID"

# 查询文章（读操作 → 备库）
curl http://10.211.55.11:8081/api/posts/$POST_ID \
  -H "Authorization: Bearer $TOKEN" \
  | jq '.'

# 验证读写分离
# 查看日志，写操作应连接 Primary，读操作应连接 Replica
grep "HikariCP" /root/CloudCom/backend/logs/blog-backend.log | tail -20
```

**3. Spark 分析测试**：

```bash
# 触发 Spark 数据分析
curl -X POST http://10.211.55.11:8081/api/stats/analyze \
  -H "Authorization: Bearer $TOKEN"

# 查看分析结果
curl http://10.211.55.11:8081/api/stats \
  -H "Authorization: Bearer $TOKEN" \
  | jq '.'

# 查看 Spark 执行日志
grep "Spark" /root/CloudCom/backend/logs/blog-backend.log | tail -30
```

**4. 主备数据同步测试**：

```bash
# 在主库写入数据
su - omm -c "gsql -d blog_db -p 5432 -c \"INSERT INTO posts (author_id, title, content, created_at, updated_at) VALUES (1, '同步测试', '测试主备同步', NOW(), NOW());\""

# 立即在备库查询（应能查到）
sleep 1
su - omm -c "gsql -d blog_db -p 5434 -c \"SELECT title FROM posts WHERE title='同步测试';\""

# 查看复制延迟
su - omm -c "gsql -d postgres -p 5432 -c \"SELECT application_name, state, sync_state, replay_lag FROM pg_stat_replication;\""
```

### 4.8 部署总结

#### 4.8.1 部署成果

本次实验成功在虚拟机环境中完成了以下部署：

1. **openGauss 9.2.4 一主二备集群**
   - 主库端口 5432，负责所有写操作
   - 备库1端口 5434，负责读操作，流复制正常
   - 备库2端口 5436，负责读操作，流复制正常
   - 主备复制延迟 < 100ms，RPO < 1s

2. **Spring Boot 后端服务**
   - 端口 8081，提供 REST API
   - 集成 HikariCP 连接池，主库 20 连接，备库 20 连接
   - 基于 AOP 实现读写分离，对业务代码透明
   - 集成 Spark 3.5.0 内嵌模式，支持大数据分析

3. **Vue 3 前端服务**
   - 端口 8080，Nginx 静态托管
   - Gzip 压缩，静态资源缓存
   - API 反向代理到后端服务

4. **运维管理工具**
   - 12+ 个自动化管理脚本
   - 完善的日志管理和监控机制
   - 服务启停、状态检查、故障排查等完整工具链

#### 4.8.2 关键配置参数

| 配置项 | 值 | 说明 |
|-------|---|------|
| VM IP | 10.211.55.11 | 固定内网 IP |
| 主库端口 | 5432 (HA: 5433) | 写操作入口 |
| 备库1端口 | 5434 (HA: 5435) | 读操作入口1 |
| 备库2端口 | 5436 (HA: 5437) | 读操作入口2 |
| 后端端口 | 8081 | REST API |
| 前端端口 | 8080 | Web UI |
| 数据库名 | blog_db | 应用数据库 |
| 数据库用户 | bloguser | 应用用户 |
| 复制用户 | replicator | 主备复制 |
| JVM 内存 | 512M-1024M | 后端 JVM 堆内存 |
| 连接池大小 | 20 (主/备) | HikariCP 最大连接数 |

#### 4.8.3 访问入口

- **前端 Web**: http://10.211.55.11:8080
- **后端 API**: http://10.211.55.11:8081/api
- **健康检查**: http://10.211.55.11:8081/actuator/health
- **数据库主库**: 10.211.55.11:5432
- **数据库备库1**: 10.211.55.11:5434
- **数据库备库2**: 10.211.55.11:5436

#### 4.8.4 部署文档

完整的部署文档和管理脚本：

- **项目 README**: `/root/CloudCom/README.md`
- **脚本文档**: `/root/CloudCom/scripts/README.md`
- **管理脚本**: `/root/CloudCom/scripts/` (12+ 脚本)
- **配置文件**: `/root/CloudCom/backend/src/main/resources/`

#### 4.8.5 后续优化建议

1. **高可用增强**
   - 配置 Keepalived + VIP 实现自动故障转移
   - 增加主库故障检测和自动切换脚本
   - 配置备库级联复制提升可扩展性

2. **性能优化**
   - 根据实际负载调整 HikariCP 连接池参数
   - 优化 openGauss 共享内存和缓存配置
   - 增加 Redis 缓存层减轻数据库压力

3. **监控告警**
   - 集成 Prometheus + Grafana 监控
   - 配置数据库性能指标采集
   - 设置关键指标告警阈值

4. **安全加固**
   - 启用 SSL/TLS 加密数据传输
   - 配置防火墙白名单规则
   - 定期备份数据库和配置文件
